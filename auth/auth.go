package auth

import (
	"errors"
	"fmt"
	"strings"

	"golang.org/x/crypto/bcrypt"
	htbasicauth "github.com/jimstudt/http-authentication/basic"

	"bitbucket.org/parqueryopen/revproxyry/config"
)

type hashing int

const (
	Apr1MD5 hashing = 0
	Bcrypt          = 1
)

type Auth struct {
	Username     string
	PasswordHash string

	hashing hashing

	// md5 represents a parsed MD5 password generated by Apache's htpasswd. Only set if MD5.
	md5 htbasicauth.EncodedPasswd
}

// newAuth creates an authentication registry based on the authentication specified in the config.
func newAuth(username string, passwordHash string) (a *Auth, err error) {
	a = &Auth{Username: username, PasswordHash: passwordHash}

	switch {
	case passwordHash == "":
		err = errors.New("empty password hash")
		return
	case strings.HasPrefix(passwordHash, "$apr1$"):
		a.hashing = Apr1MD5

		a.md5, err = htbasicauth.AcceptMd5(passwordHash)
		if err != nil {
			err = fmt.Errorf("failed to parse Apr1 MD5 hash: %s", passwordHash)
			return
		}

	case strings.HasPrefix(passwordHash, "$2a$") ||
		strings.HasPrefix(passwordHash, "$2y$"):
		a.hashing = Bcrypt

	default:
		err = fmt.Errorf("unknown prefix of the password hash: %s", passwordHash)
		return
	}

	return
}

// Auths represents an authentication registry. Each authentication is mapped {authentication ID} -> authentication.
type Auths struct {
	registry map[string]*Auth
	All      bool // if All is true, everybody is granted access.
}

// New creates a new authentication registry.
func New(cfgAuths map[string]*config.Auth) (auths *Auths, err error) {
	auths = &Auths{}

	if len(cfgAuths) == 0 {
		// If there are no authentications specified, everybody is granted access.
		auths.All = true
		return
	} else {
		// If one of the user names is empty, everybody is granted access.
		hasEmptyUsername := false

		for _, cfgAuth := range cfgAuths {
			if cfgAuth.Username == "" {
				hasEmptyUsername = true
			}
		}

		if hasEmptyUsername {
			auths.All = true
			return
		}
	}

	auths.registry = make(map[string]*Auth)

	for id, cfgAuth := range cfgAuths {
		auths.registry[id], err = newAuth(cfgAuth.Username, cfgAuth.PasswordHash)
		if err != nil {
			err = fmt.Errorf("failed to create an authentication from the configuration of an auth %s: %s",
				id, err.Error())
			return
		}
	}

	return
}

// Authenticate checks whether the user is authentic by checking his/her password against the authentication registry.
//
// If the authentication passes, ok is set to true. In case that the authentication fails, ok is false and the message
// indicates the reason of the authentication failure.
//
// If there was an error during the authentication, err will be set.
func (aa *Auths) Authenticate(username string, password string) (ok bool, msg string, err error) {
	if aa.All {
		ok = true
		return
	}

	a, hasUsername := aa.registry[username]
	if !hasUsername {
		msg = fmt.Sprintf("unknown user name: %s", username)
		return
	}

	switch a.hashing {
	case Apr1MD5:
		if a.md5.MatchesPassword(password) {
			ok = true
			return
		}

		msg = "invalid password"
		return

	case Bcrypt:
		err = bcrypt.CompareHashAndPassword([]byte(a.PasswordHash), []byte(password))
		switch {
		case err == nil:
			ok = true
			return

		case err == bcrypt.ErrMismatchedHashAndPassword:
			// We need to void the error, since we set the message separately, and this case indicates that there was actually no authentication error.
			err = nil
			ok = false
			msg = "invalid password"
			return

		default:
			return
		}

	default:
		panic(fmt.Sprintf("unhandled case: %d", a.hashing))
	}
}
